There are three types of hazards to deal with as a computer designer: Structural hazards, data hazards and control hazards. Structural hazards occur when a combination of instructions is not supported by the architecture. This can happen if two functions at the same time try to use the ALU, or if a register is both written to and read from at the same time. In this case some data can be lost due to a structural hazard. Due to the fixed and independent pipeline structure of the MIPS processor, structural hazards should not occur. %?? unless only single register between pipeline stages is implemented. 

Data hazards occur when data from one instruction is to be used in one of the following instructions dependent of the instruction. The following example shows a data hazard:

\begin{itemize}
\item[] Add \$4, \$5, \$6 \# add1
\item[] Add \$3, \$4, \$5 \# add2
\end{itemize}

The value of register four is available after the fifth stage in the pipeline of the first add instruction. The register read of the second add instruction has however to be present in the second stage. If there is no hardware solution to the problem bubbles or NOP operations have to be inserted between the lines in the assembler code. NOP operations consist of all zeros\footnote{This translates into sll 0 \$0, \$0, \$0, which means that the contents of register zero should be left shifted by zero places and stored back. This, of course, does nothing to the data.}, and are inserted to instruct the processor to do nothing for one clock period. The hardware solution is to insert forwarding which allows the two add operations to be executed right after each other. The data is written back to the register in stage five, but with forwarding the second add instruction can read the the result of the first add operation directly, and thus does not have to wait for it to be stored in the register.

A data hazard, that cannot be solved by forwarding, is the hazard that occurs, when a value loaded from memory is to be used in the subsequent instruction. Since the data is not fetched from memory until the memory access (MEM) stage, and the data is to be used in the execute stage (EX) of the subsequent instruction, it is impossible to solve this dependency by forwarding.This means, that even with forwarding, at least one bubble (NOP) has to be inserted if the value of this function has to be used in the next. To optimize the performance the program can be optimized at assembler level to remove as many data hazards as possible, by rearranging the code. This is, however, more of a software problem than a hardware problem. This example shows that a computer designer both has to be aware of software and hardware implementations in order to be successful. In our design we have implemented forwarding and thus NOPs do not have to be inserted at every dependency. 

The last hazard is control hazards; these hazards occur when branching. The processor cannot know in advance whether to branch or not, and therefore NOPs have to be implemented after a branch. There are many approaches to branch prediction, and some of them can predict the result with great accuracy, but since we have not implemented branch prediction we will not discuss it further. In our design NOPs have to be inserted manually in the assembler after every LW and branch instructions. If a C program is compiled using the gcc compiler, this program has to be investigated in order to manually insert the necessary NOPs.

