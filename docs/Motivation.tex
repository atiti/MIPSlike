
\subsection{Motivation}
The MIPS instruction set is well tested, and has a lot of advantages. The fixed length 32-bit instruction words allow for smarter hardware implementation, especially since the structure of the instruction words is fixed, so that instructions can be passed on through pipelined stages and be decoded along the way, instead of having to be decoded all at once.

By using the almost\footnote{Due to time constraints, not all instructions of the MIPS core instruction set were implemented. These are the byte and halfword instructions along with the conditional store} full core instruction set (as seen in Appendix \ref{list}), we have the advantage of being able to compile real programs into MIPS assembler code, which can be run directly on our processor. Had we instead chosen to work on a modified version of the MIPS instruction set or a smaller subset, a compiler would have had to be written from scratch, or any program that was to run on the processor would have to be written in assembler. Both these solutions would involve a lot of work, which would not be directly relevant for the purpose of this course\footnote{As it turns out, some extra effort still had to be put into the code translation, since there were a few bugs in the gcc MIPS compiler as described in section \ref{sec:gcc}}. With the chosen subset of instructions, only small modifications had to be made to the assembler code generated by the gcc, before it could run.
